{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Configuring Your Bindings \u00b6 All bindings for Juicy are configured by extending the AbstractModule . Your bindings can be provided either through attributed methods, or explicitly by calling the Bind<T>() , BindMany<T>() , and BindFactory<T>() methods. public sealed class Module : AbstractModule { public void Configure () { Bind < IService >() . To < ServiceImpl >() . In ( BindingScope . Singleton ); Bind < int >() . ToInstance ( 5 ) . Named ( \"toDouble\" ); BindMany < List < ICommand >>() . To < InitializeCommand >() . To < PauseCommand >() . To < StartCommand >(); BindFactory < IModelFactory >() . Implement < IModel , ModelImpl >(); } [Provides] [Named(\"doubledNumber\")] [Scope(BindingScope.Singleton)] public int ProvideDoubledNumber ([ Named ( \"toDouble\" )] int five ) { return five * 2 ; } } For more information about bindings, see Bindings . Injecting Values \u00b6 In order to make use of bindings, Juicy must know which constructors are \"safe\" to inject. To do this, you they will be marked with an [Inject] attribute. A class can only have ONE injectable constructor. If an attributed constructor is not found, Juicy will look for a default constructor. public interface IService { int Handle ( int number ); } public sealed class ServiceImpl : IService { private readonly int number ; [Inject] private ServiceImpl ([ Named ( \"toDouble\" )] int number ) { this . number = number ; } public void Handle ( int number ) { return number * 2 ; } } Creating an Injector \u00b6 An injector is the entrypoint for all injection in Juicy. Each injector can be provided with an array of modules to load bindings from. An injector exposes two generic methods which are used to access all bindings. For unnamed bindings, IInjector.Get<T>() , while IInjector.Get<T>(string) is used for named bindings. public static class Program { private static void Main ( string [] args ) { var injector = Juicer . CreateInjector ( new Module ()); var service = injector . Get < IService >(); var number = injector . Get < int >( \"toDouble\" ); var doubledNumber = injector . Get < int >( \"doubledNumber\" ); Console . WriteLine ( service . Handle ( number ) == doubledNumber ); } } Creating Child Injectors \u00b6 Child injectors contain their own bindings, but will delegate to the injector that created them if a requested type has no bindings. This can be useful in situations where an implementation cannot be decided until after startup and requires additional dependencies to be installed. public sealed class Module : AbstractModule { [Provides] [Scope(BindingScope.Singleton)] DbConnection ProvideDbConnection ( string connectionType ) { IInjector injector ; switch ( connectionType ) { case \"sqlite\" : injector = CreateChildInjector ( new SqliteModule ()); break ; case \"postgres\" : injector = CreateChildInjector ( new PostgresModule ()); break ; case \"mysql\" : injector = CreateChildInjector ( new MysqlModule ()); break ; default : throw new InvalidOperationException ( \"Could not determine DbConnection type.\" ); } return injector . Get < DbConnection >(); } } I know the examples are bad, but hopefully they get the idea across. Especially that last example.","title":"Getting Started"},{"location":"#configuring-your-bindings","text":"All bindings for Juicy are configured by extending the AbstractModule . Your bindings can be provided either through attributed methods, or explicitly by calling the Bind<T>() , BindMany<T>() , and BindFactory<T>() methods. public sealed class Module : AbstractModule { public void Configure () { Bind < IService >() . To < ServiceImpl >() . In ( BindingScope . Singleton ); Bind < int >() . ToInstance ( 5 ) . Named ( \"toDouble\" ); BindMany < List < ICommand >>() . To < InitializeCommand >() . To < PauseCommand >() . To < StartCommand >(); BindFactory < IModelFactory >() . Implement < IModel , ModelImpl >(); } [Provides] [Named(\"doubledNumber\")] [Scope(BindingScope.Singleton)] public int ProvideDoubledNumber ([ Named ( \"toDouble\" )] int five ) { return five * 2 ; } } For more information about bindings, see Bindings .","title":"Configuring Your Bindings"},{"location":"#injecting-values","text":"In order to make use of bindings, Juicy must know which constructors are \"safe\" to inject. To do this, you they will be marked with an [Inject] attribute. A class can only have ONE injectable constructor. If an attributed constructor is not found, Juicy will look for a default constructor. public interface IService { int Handle ( int number ); } public sealed class ServiceImpl : IService { private readonly int number ; [Inject] private ServiceImpl ([ Named ( \"toDouble\" )] int number ) { this . number = number ; } public void Handle ( int number ) { return number * 2 ; } }","title":"Injecting Values"},{"location":"#creating-an-injector","text":"An injector is the entrypoint for all injection in Juicy. Each injector can be provided with an array of modules to load bindings from. An injector exposes two generic methods which are used to access all bindings. For unnamed bindings, IInjector.Get<T>() , while IInjector.Get<T>(string) is used for named bindings. public static class Program { private static void Main ( string [] args ) { var injector = Juicer . CreateInjector ( new Module ()); var service = injector . Get < IService >(); var number = injector . Get < int >( \"toDouble\" ); var doubledNumber = injector . Get < int >( \"doubledNumber\" ); Console . WriteLine ( service . Handle ( number ) == doubledNumber ); } }","title":"Creating an Injector"},{"location":"#creating-child-injectors","text":"Child injectors contain their own bindings, but will delegate to the injector that created them if a requested type has no bindings. This can be useful in situations where an implementation cannot be decided until after startup and requires additional dependencies to be installed. public sealed class Module : AbstractModule { [Provides] [Scope(BindingScope.Singleton)] DbConnection ProvideDbConnection ( string connectionType ) { IInjector injector ; switch ( connectionType ) { case \"sqlite\" : injector = CreateChildInjector ( new SqliteModule ()); break ; case \"postgres\" : injector = CreateChildInjector ( new PostgresModule ()); break ; case \"mysql\" : injector = CreateChildInjector ( new MysqlModule ()); break ; default : throw new InvalidOperationException ( \"Could not determine DbConnection type.\" ); } return injector . Get < DbConnection >(); } } I know the examples are bad, but hopefully they get the idea across. Especially that last example.","title":"Creating Child Injectors"},{"location":"bindings/collections/","text":"Collection Bindings \u00b6 Collection bindings make use of the BindMany<T>() method within a module. They allow you to bind multiple implementations of a service together. BindMany < List < ICommand >>() . To < InitializeCommand >() . To < PauseCommand >() . To < StartCommand >() . In ( BindingScope . Singleton ); You must use the same type specified in the original BindMany<T>() call in order to have the values injected. public sealed class ServiceImpl { private List < ICommand > commands ; private ServiceImpl ( List < ICommand > commands ) { this . commands = commands ; } ... } Using with Untargeted Bindings \u00b6 Untargeted Bindings can be used in conjunction with collection bindings to determine how the individual implementing types are instantiated. In the above example, the List<ICommand> is bound as a singleton, so the entire list of values is cached after it is created. If you decided to inject a single command into another class, it would default to being instance-scoped. BindMany < List < ICommand >>() . To < InitializeCommand >() . To < PauseCommand >() . To < StartCommand >() . In ( BindingScope . Singleton ); Bind < PauseCommand >() . In ( BindingScope . Singleton ); The PauseCommand will now share its instance with the List<ICommand> binding, regardless of the order in which they are requested. Limitations \u00b6 The type provided when calling BindMany<T>() must inherit from IEnumerable AND have an Add(value) method.","title":"Collections"},{"location":"bindings/collections/#collection-bindings","text":"Collection bindings make use of the BindMany<T>() method within a module. They allow you to bind multiple implementations of a service together. BindMany < List < ICommand >>() . To < InitializeCommand >() . To < PauseCommand >() . To < StartCommand >() . In ( BindingScope . Singleton ); You must use the same type specified in the original BindMany<T>() call in order to have the values injected. public sealed class ServiceImpl { private List < ICommand > commands ; private ServiceImpl ( List < ICommand > commands ) { this . commands = commands ; } ... }","title":"Collection Bindings"},{"location":"bindings/collections/#using-with-untargeted-bindings","text":"Untargeted Bindings can be used in conjunction with collection bindings to determine how the individual implementing types are instantiated. In the above example, the List<ICommand> is bound as a singleton, so the entire list of values is cached after it is created. If you decided to inject a single command into another class, it would default to being instance-scoped. BindMany < List < ICommand >>() . To < InitializeCommand >() . To < PauseCommand >() . To < StartCommand >() . In ( BindingScope . Singleton ); Bind < PauseCommand >() . In ( BindingScope . Singleton ); The PauseCommand will now share its instance with the List<ICommand> binding, regardless of the order in which they are requested.","title":"Using with Untargeted Bindings"},{"location":"bindings/collections/#limitations","text":"The type provided when calling BindMany<T>() must inherit from IEnumerable AND have an Add(value) method.","title":"Limitations"},{"location":"bindings/explicit/","text":"Explicit Bindings \u00b6 Explicit bindings make use of the Bind<T>() method within a module. Type \u00b6 Allows you to define what implementation of type you will use, but lets the injector create it for you. Bind < IService >() . To < ServiceImpl >() . In ( BindingScope . Singleton ); ... public sealed class ServiceConsumer { private IService service ; [Inject] private ServiceConsumer ( IService service ) { this . service = service ; } } Trying to use type bindings with value-types WILL result in errors. Untargeted \u00b6 An untargeted binding specifies a concrete class when calling Bind<T>() . This can be used to make the injector aware of a type and modify the scope or name of the binding. Bind < ServiceImpl >() . In ( BindingScope . Singleton ); Note: These can be used in conjunction with normal bindings. They will, however, both share the same cache if set to be singletons. Instances are cached based on the implementation type. Instance \u00b6 Bind to a specific instance of a type. This is primarily used when binding to primitives. Bind < int >() . ToInstance ( 8000 ) . Named ( \"port\" ); Bind < string >() . ToInstance ( \"/service\" ) . Named ( \"path\" ); ... public sealed class ServiceImpl : IService { private int port ; private string path ; [Inject] private ServiceImpl ( [Named(\"port\")] int port , [Named(\"path\")] string path ) { this . port = port ; this . path = path ; } } Instance bindings default to the Singleton scope. While you can override scope, doing so WILL result in the injector trying to instantiate the types instead.","title":"Explicit"},{"location":"bindings/explicit/#explicit-bindings","text":"Explicit bindings make use of the Bind<T>() method within a module.","title":"Explicit Bindings"},{"location":"bindings/explicit/#type","text":"Allows you to define what implementation of type you will use, but lets the injector create it for you. Bind < IService >() . To < ServiceImpl >() . In ( BindingScope . Singleton ); ... public sealed class ServiceConsumer { private IService service ; [Inject] private ServiceConsumer ( IService service ) { this . service = service ; } } Trying to use type bindings with value-types WILL result in errors.","title":"Type"},{"location":"bindings/explicit/#untargeted","text":"An untargeted binding specifies a concrete class when calling Bind<T>() . This can be used to make the injector aware of a type and modify the scope or name of the binding. Bind < ServiceImpl >() . In ( BindingScope . Singleton ); Note: These can be used in conjunction with normal bindings. They will, however, both share the same cache if set to be singletons. Instances are cached based on the implementation type.","title":"Untargeted"},{"location":"bindings/explicit/#instance","text":"Bind to a specific instance of a type. This is primarily used when binding to primitives. Bind < int >() . ToInstance ( 8000 ) . Named ( \"port\" ); Bind < string >() . ToInstance ( \"/service\" ) . Named ( \"path\" ); ... public sealed class ServiceImpl : IService { private int port ; private string path ; [Inject] private ServiceImpl ( [Named(\"port\")] int port , [Named(\"path\")] string path ) { this . port = port ; this . path = path ; } } Instance bindings default to the Singleton scope. While you can override scope, doing so WILL result in the injector trying to instantiate the types instead.","title":"Instance"},{"location":"bindings/factories/","text":"Factory Bindings \u00b6 Factory bindings make use of the BindFactory<T>() method within a module. They allow you to create implementations of a type with consumer-provided values. public IConnectionFactory { IConnection Create ( string url , int port ); } public Connection : IConnection { private string url ; private int port ; private IConnectionConfiguration configuration ; [Inject] private Connection ( string url , int port , IConnectionConfiguration configuration ) { this . url = url ; this . port = port ; this . configuration = configuration ; } } ... BindFactory < IConnectionFactory >() . Implement < IConnection , Connection >(); ... var factory = injector . Get < IConnectionFactory >(); var connection = factory . Create ( \"/service\" , 8000 ); In the above example, the fields url and port are passed from the factory to the new Connection instance. The configuration field is supplied by the injector. Named Parameters \u00b6 If you have multiple parameters of the same type, it is necessary to name them, otherwise injection is not possible. public IPersonFactory { IPerson Create ( [Name(\"firstname\")] string firstname , [Name(\"lastname\")] string lastname , int age ); } public Person : IPerson { private string firstname ; private string lastname ; private int age ; [Inject] private Person ( [Name(\"firstname\")] string firstname , [Name(\"lastname\")] string lastname , int age ) { this . firstname = firstname ; this . lastname = lastname ; this . age = age ; } } ... BindFactory < IPersonFactory >() . Implement < IPerson , Person >(); ... var factory = injector . Get < IPersonFactory >(); var person = factory . Create ( \"John\" , \"Smith\" ); This example is really bad, but I was having trouble thinking of something to illustrate this.","title":"Factories"},{"location":"bindings/factories/#factory-bindings","text":"Factory bindings make use of the BindFactory<T>() method within a module. They allow you to create implementations of a type with consumer-provided values. public IConnectionFactory { IConnection Create ( string url , int port ); } public Connection : IConnection { private string url ; private int port ; private IConnectionConfiguration configuration ; [Inject] private Connection ( string url , int port , IConnectionConfiguration configuration ) { this . url = url ; this . port = port ; this . configuration = configuration ; } } ... BindFactory < IConnectionFactory >() . Implement < IConnection , Connection >(); ... var factory = injector . Get < IConnectionFactory >(); var connection = factory . Create ( \"/service\" , 8000 ); In the above example, the fields url and port are passed from the factory to the new Connection instance. The configuration field is supplied by the injector.","title":"Factory Bindings"},{"location":"bindings/factories/#named-parameters","text":"If you have multiple parameters of the same type, it is necessary to name them, otherwise injection is not possible. public IPersonFactory { IPerson Create ( [Name(\"firstname\")] string firstname , [Name(\"lastname\")] string lastname , int age ); } public Person : IPerson { private string firstname ; private string lastname ; private int age ; [Inject] private Person ( [Name(\"firstname\")] string firstname , [Name(\"lastname\")] string lastname , int age ) { this . firstname = firstname ; this . lastname = lastname ; this . age = age ; } } ... BindFactory < IPersonFactory >() . Implement < IPerson , Person >(); ... var factory = injector . Get < IPersonFactory >(); var person = factory . Create ( \"John\" , \"Smith\" ); This example is really bad, but I was having trouble thinking of something to illustrate this.","title":"Named Parameters"},{"location":"bindings/methods/","text":"Method Bindings \u00b6 Useful when you need to inject a class that isn't correctly attributed for injections. This usually includes 3 rd party dependencies. public sealed class Module : AbstractModule { [Provides] [Singleton] public DbConnection ProvideDatabaseConnection ( [Named(\"connectionString\")] string connectionString ) { return new SqliteConnection ( connectionString ); } } ... public sealed class PersonServiceImpl { private DbConnection connection ; [Inject] private PersonServiceImpl ( DbConnection connection ) { this . connection = connection ; } public IPerson GetByFirstName ( string firstname ) { // use connection } } Bindings of this type are only detected when they are within a subclass of AbstractModule .","title":"Methods"},{"location":"bindings/methods/#method-bindings","text":"Useful when you need to inject a class that isn't correctly attributed for injections. This usually includes 3 rd party dependencies. public sealed class Module : AbstractModule { [Provides] [Singleton] public DbConnection ProvideDatabaseConnection ( [Named(\"connectionString\")] string connectionString ) { return new SqliteConnection ( connectionString ); } } ... public sealed class PersonServiceImpl { private DbConnection connection ; [Inject] private PersonServiceImpl ( DbConnection connection ) { this . connection = connection ; } public IPerson GetByFirstName ( string firstname ) { // use connection } } Bindings of this type are only detected when they are within a subclass of AbstractModule .","title":"Method Bindings"},{"location":"bindings/overview/","text":"Binding Scopes \u00b6 Currently, only two binding scopes are supported: Instance and Singleton . When using any Bind* method within a modules Configure method, scope is set using BindingBuilder.Scope(BindingScope scope) . For bindings provided through methods, the Scope attribute can be used [Scope(BindingScope scope)] . Instance \u00b6 Any bindings with an instanced scope will be created every time they are requested. Their values will never be cached. You should never have to explicitly state this scope. Singleton \u00b6 Singleton bindings will be cached once they are requested for the first time. The cached value will be returned for any subsequent requests. Certain bindings ( instance ) will default to this scope. While you can alter scope of these bindings explicitly, doing so is discouraged. Binding Names \u00b6 Bindings can either be named or unnamed . Named bindings allow you to differentiate between bindings of the same type. Binding Conflicts \u00b6 To avoid binding conflicts, you should follow two rules Only create one unnamed binding for a given type. Only create one binding the same name of a given type. Failure to do so will cause an InvalidOperationException to be thrown when creating your injector with Juicer.CreateInjector(...) . Here is an example of a module that breaks both of these rules: public sealed class BadModule : AbstractModule { public void Configure () { Bind < IService >() . To < ServiceImpl >() . In ( BindingScope . Singleton ); Bind < int >() . ToInstance ( 8000 ) . Named ( \"port\" ); } [Provides] [Scope(BindingScope.Singleton)] IService ProvideService ([ Named ( \"port\" )] port ) { return new OtherServiceImpl ( port ); } [Provides] [Named(\"port\")] [Scope(BindingScope.Singleton)] int ProvidePort ( Configuration configuration ) { return configuration . GetPort (); } } Lazily-Loaded Bindings \u00b6 Any type that can be injected through Juicy can also be lazily-loaded by using injecting an IProvider<T> in place of the type you want. These can be useful in situations where: Implementations do not have all required dependencies when they are first injected. Types reference eachother, so creation of one must be deferred until the other is created. Objects are expensive to create and are only injected when they are needed. Bind < IService >() . To < ServiceImpl >() . In ( BindingScope . Singleton ); ... public sealed class ServiceConsumer { private IProvider < IService > serviceProvider ; [Inject] private ServiceConsumer ( IProvider < IService > serviceProvider ) { this . serviceProvider = serviceProvider ; } public void Foo () { var service = serviceProvider . Get (); // use service } } Built-in Bindings \u00b6 Built-in bindings are created automatically. They are included even if an injector is created with no modules. Currently, this only includes the injector itself. public sealed class InjectorExample { private IInjector injector private InjectorExample ( IInjector injector ) { this . injector = injector ; } } ... var injectorExample = injector . Get < InjectorExample >(); InjectorExample now has access to the injector that was used to create it. Using the injector in this way should be avoided.","title":"Overview"},{"location":"bindings/overview/#binding-scopes","text":"Currently, only two binding scopes are supported: Instance and Singleton . When using any Bind* method within a modules Configure method, scope is set using BindingBuilder.Scope(BindingScope scope) . For bindings provided through methods, the Scope attribute can be used [Scope(BindingScope scope)] .","title":"Binding Scopes"},{"location":"bindings/overview/#instance","text":"Any bindings with an instanced scope will be created every time they are requested. Their values will never be cached. You should never have to explicitly state this scope.","title":"Instance"},{"location":"bindings/overview/#singleton","text":"Singleton bindings will be cached once they are requested for the first time. The cached value will be returned for any subsequent requests. Certain bindings ( instance ) will default to this scope. While you can alter scope of these bindings explicitly, doing so is discouraged.","title":"Singleton"},{"location":"bindings/overview/#binding-names","text":"Bindings can either be named or unnamed . Named bindings allow you to differentiate between bindings of the same type.","title":"Binding Names"},{"location":"bindings/overview/#binding-conflicts","text":"To avoid binding conflicts, you should follow two rules Only create one unnamed binding for a given type. Only create one binding the same name of a given type. Failure to do so will cause an InvalidOperationException to be thrown when creating your injector with Juicer.CreateInjector(...) . Here is an example of a module that breaks both of these rules: public sealed class BadModule : AbstractModule { public void Configure () { Bind < IService >() . To < ServiceImpl >() . In ( BindingScope . Singleton ); Bind < int >() . ToInstance ( 8000 ) . Named ( \"port\" ); } [Provides] [Scope(BindingScope.Singleton)] IService ProvideService ([ Named ( \"port\" )] port ) { return new OtherServiceImpl ( port ); } [Provides] [Named(\"port\")] [Scope(BindingScope.Singleton)] int ProvidePort ( Configuration configuration ) { return configuration . GetPort (); } }","title":"Binding Conflicts"},{"location":"bindings/overview/#lazily-loaded-bindings","text":"Any type that can be injected through Juicy can also be lazily-loaded by using injecting an IProvider<T> in place of the type you want. These can be useful in situations where: Implementations do not have all required dependencies when they are first injected. Types reference eachother, so creation of one must be deferred until the other is created. Objects are expensive to create and are only injected when they are needed. Bind < IService >() . To < ServiceImpl >() . In ( BindingScope . Singleton ); ... public sealed class ServiceConsumer { private IProvider < IService > serviceProvider ; [Inject] private ServiceConsumer ( IProvider < IService > serviceProvider ) { this . serviceProvider = serviceProvider ; } public void Foo () { var service = serviceProvider . Get (); // use service } }","title":"Lazily-Loaded Bindings"},{"location":"bindings/overview/#built-in-bindings","text":"Built-in bindings are created automatically. They are included even if an injector is created with no modules. Currently, this only includes the injector itself. public sealed class InjectorExample { private IInjector injector private InjectorExample ( IInjector injector ) { this . injector = injector ; } } ... var injectorExample = injector . Get < InjectorExample >(); InjectorExample now has access to the injector that was used to create it. Using the injector in this way should be avoided.","title":"Built-in Bindings"}]}